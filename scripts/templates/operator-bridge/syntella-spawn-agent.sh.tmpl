#!/usr/bin/env bash
set -euo pipefail

AGENT_ID="${1:-}"
ROLE="${2:-}"
DISCORD_BOT_TOKEN_AGENT="${3:-}"
PORT="${4:-}"

[[ -n "$AGENT_ID" && -n "$ROLE" && -n "$DISCORD_BOT_TOKEN_AGENT" ]] || { echo "usage: syntella-spawn-agent <agent_id> <role> <discord_token> [port]"; exit 2; }

if [[ -z "$PORT" ]]; then
  PORT="$(python3 - <<'PY'
import json, os
p=os.path.expanduser('~/.openclaw/workspace/agents/registry.json')
base=19002
used=set()
if os.path.exists(p):
  try:
    d=json.load(open(p))
    for v in d.values():
      port=v.get('port')
      if isinstance(port,int): used.add(port)
  except Exception:
    pass
port=base
while port in used:
  port+=1
print(port)
PY
)"
fi

set -a
source /etc/openclaw/openclaw.env
set +a

# Hard isolation: each spawned bot gets its own OpenClaw home/runtime.
CHILD_HOME="$HOME/.openclaw-$AGENT_ID"
CHILD_PROFILE="main"
SHARED_WS_ROOT="$HOME/.openclaw/workspace"
AGENT_WS="$SHARED_WS_ROOT/$AGENT_ID"

oc_child() { OPENCLAW_HOME="$CHILD_HOME" openclaw --profile "$CHILD_PROFILE" "$@"; }

main_token_before="$(openclaw config get channels.discord.token 2>/dev/null | tr -d '"[:space:]' || true)"

mkdir -p "$AGENT_WS/memory" "$SHARED_WS_ROOT/agents" "$CHILD_HOME"

# Pre-clean stale/invalid keys before any `openclaw config set` calls.
python3 - <<'PY' "$CHILD_HOME"
import json, os, sys
home=sys.argv[1]
cfg_path=os.path.join(home, '.openclaw-main', 'openclaw.json')
if os.path.exists(cfg_path):
    try:
        cfg=json.load(open(cfg_path, 'r', encoding='utf-8'))
    except Exception:
        cfg={}
    agents=cfg.get('agents')
    if isinstance(agents, dict) and 'main' in agents:
        agents.pop('main', None)
        json.dump(cfg, open(cfg_path, 'w', encoding='utf-8'), indent=2)
PY
cp "$SHARED_WS_ROOT"/AGENTS.SPAWNED.md "$AGENT_WS/AGENTS.md" 2>/dev/null || true
DISPLAY_NAME="$(python3 - <<'PY' "$AGENT_ID"
import sys
s=sys.argv[1].replace('-', ' ').strip()
print(' '.join(w.capitalize() for w in s.split()) or sys.argv[1])
PY
)"
sed -i "s|__AGENT_NAME__|${DISPLAY_NAME}|g" "$AGENT_WS/AGENTS.md" 2>/dev/null || true

# Ensure child runtime has provider env fallback.
mkdir -p "$CHILD_HOME/.openclaw-main"
if [[ -f "$HOME/.openclaw/.env" ]]; then
  cp "$HOME/.openclaw/.env" "$CHILD_HOME/.env"
elif [[ -n "${MOONSHOT_API_KEY:-}" ]]; then
  {
    [[ -n "${MOONSHOT_API_KEY:-}" ]] && echo "MOONSHOT_API_KEY=${MOONSHOT_API_KEY}"
  } > "$CHILD_HOME/.env"
fi
# Some builds resolve runtime env fallback from profile-scoped state dir.
cp "$CHILD_HOME/.env" "$CHILD_HOME/.openclaw-main/.env" 2>/dev/null || true
chmod 600 "$CHILD_HOME/.env" "$CHILD_HOME/.openclaw-main/.env" 2>/dev/null || true

# Mirror auth profiles from main runtime when present (avoids missing-provider-key failures).
MAIN_AUTH_PATH="$(find "$HOME/.openclaw" -type f -path '*/agents/main/agent/auth-profiles.json' 2>/dev/null | head -n1 || true)"
if [[ -n "$MAIN_AUTH_PATH" && -f "$MAIN_AUTH_PATH" ]]; then
  REL_AUTH_PATH="${MAIN_AUTH_PATH#"$HOME/.openclaw/"}"
  CHILD_AUTH_PATH="$CHILD_HOME/$REL_AUTH_PATH"
  mkdir -p "$(dirname "$CHILD_AUTH_PATH")"
  cp "$MAIN_AUTH_PATH" "$CHILD_AUTH_PATH"
  chmod 600 "$CHILD_AUTH_PATH" 2>/dev/null || true
fi

# SOUL.md and TEAM.md are updated in the final registry write step.

oc_child config set agents.defaults.workspace "$AGENT_WS"
oc_child config set agents.defaults.model.primary "moonshot/kimi-k2.5"
oc_child config set agents.defaults.model.fallbacks '[]' || true
oc_child config set gateway.mode local
oc_child config set gateway.bind loopback
oc_child config set gateway.auth.mode token
oc_child config set channels.discord.enabled true
oc_child config set channels.discord.groupPolicy "allowlist"
oc_child config set channels.discord.allowBots true
oc_child config set channels.discord.token "$DISCORD_BOT_TOKEN_AGENT"
oc_child config set channels.discord.dm.enabled true
oc_child config set channels.discord.dm.policy "allowlist"
oc_child config set channels.discord.dm.allowFrom '["__DISCORD_HUMAN_ID__"]'
oc_child config set channels.discord.dm.groupEnabled false
# Newer OpenClaw schemas may use flattened DM keys; set both forms.
oc_child config set channels.discord.dmPolicy "allowlist"
oc_child config set channels.discord.allowFrom '["__DISCORD_HUMAN_ID__"]'

GUILDS_JSON="$(python3 - <<'PY'
import json
print(json.dumps({
  "__DISCORD_GUILD_ID__": {
    "requireMention": False,
    "users": ["__DISCORD_HUMAN_ID__"],
    "channels": {
      "__DISCORD_CHANNEL_ID__": {"allow": True, "requireMention": False}
    }
  }
}))
PY
)"
oc_child config set channels.discord.guilds "$GUILDS_JSON"
oc_child config set tools.exec.host gateway
oc_child config set tools.exec.security full
oc_child config set tools.exec.ask off

# Hard-pin model keys directly in JSON for schema/version drift tolerance.
python3 - <<'PY' "$CHILD_HOME"
import json, os, sys
home=sys.argv[1]
cfg_path=os.path.join(home, '.openclaw-main', 'openclaw.json')
os.makedirs(os.path.dirname(cfg_path), exist_ok=True)
cfg={}
if os.path.exists(cfg_path):
    try:
        cfg=json.load(open(cfg_path, 'r', encoding='utf-8'))
    except Exception:
        cfg={}
agents=cfg.setdefault('agents', {})
defs=agents.setdefault('defaults', {})
defs.setdefault('model', {})['primary']='moonshot/kimi-k2.5'
defs.setdefault('model', {})['fallbacks']=[]
# Remove invalid key for older/newer schemas that reject agents.main.
if isinstance(agents, dict) and 'main' in agents:
    agents.pop('main', None)
json.dump(cfg, open(cfg_path, 'w', encoding='utf-8'), indent=2)
PY

# Normalize schema changes before startup (required on some builds).
OPENCLAW_HOME="$CHILD_HOME" openclaw --profile "$CHILD_PROFILE" doctor --fix >/dev/null 2>&1 || true

child_group_policy="$(OPENCLAW_HOME="$CHILD_HOME" openclaw --profile "$CHILD_PROFILE" config get channels.discord.groupPolicy 2>/dev/null | tr -d '"[:space:]' || true)"
child_guild_allow="$(OPENCLAW_HOME="$CHILD_HOME" openclaw --profile "$CHILD_PROFILE" config get channels.discord.guilds.__DISCORD_GUILD_ID__.channels.__DISCORD_CHANNEL_ID__.allow 2>/dev/null | tr -d '"[:space:]' || true)"
child_model_primary="$(OPENCLAW_HOME="$CHILD_HOME" openclaw --profile "$CHILD_PROFILE" config get agents.defaults.model.primary 2>/dev/null | tr -d '"[:space:]' || true)"
if [[ "$child_group_policy" != "allowlist" || "$child_guild_allow" != "true" ]]; then
  echo "ERROR: child guild allowlist wiring failed (groupPolicy=${child_group_policy:-<unset>}, channelAllow=${child_guild_allow:-<unset>})" >&2
  OPENCLAW_HOME="$CHILD_HOME" openclaw --profile "$CHILD_PROFILE" config get channels.discord.guilds >&2 || true
  exit 1
fi
if [[ "$child_model_primary" != moonshot/* && "$child_model_primary" != "moonshot/kimi-k2.5" ]]; then
  echo "ERROR: child model wiring failed (agents.defaults.model.primary=${child_model_primary:-<unset>})" >&2
  exit 1
fi
if ! grep -q '^MOONSHOT_API_KEY=' "$CHILD_HOME/.openclaw-main/.env" 2>/dev/null; then
  echo "ERROR: child Moonshot key missing in $CHILD_HOME/.openclaw-main/.env" >&2
  exit 1
fi

main_token_after="$(openclaw config get channels.discord.token 2>/dev/null | tr -d '"[:space:]' || true)"
if [[ -n "$main_token_before" && "$main_token_before" != "$main_token_after" ]]; then
  echo "ERROR: main profile discord token changed during child spawn; aborting to protect main bot." >&2
  exit 1
fi

nohup env OPENCLAW_HOME="$CHILD_HOME" OPENCLAW_PROFILE="$CHILD_PROFILE" MOONSHOT_API_KEY="${MOONSHOT_API_KEY:-}" openclaw --profile "$CHILD_PROFILE" gateway --allow-unconfigured --port "$PORT" > "$AGENT_WS/gateway.log" 2>&1 &

ready=0
for _ in $(seq 1 25); do
  if grep -q "listening on ws://127.0.0.1:${PORT}" "$AGENT_WS/gateway.log" 2>/dev/null; then
    ready=1
    break
  fi
  sleep 1
done

if [[ "$ready" != "1" ]]; then
  echo "ERROR: child gateway did not become ready on port $PORT" >&2
  tail -n 80 "$AGENT_WS/gateway.log" >&2 || true
  exit 1
fi

python3 - <<'PY' "$AGENT_ID" "$PORT" "$ROLE" "$CHILD_HOME"
import json, os, sys
agent,port,role_raw,home=sys.argv[1],int(sys.argv[2]),sys.argv[3],sys.argv[4]
if ' — ' in role_raw:
  role, personality = role_raw.split(' — ', 1)
else:
  role, personality = role_raw, ''

# 1) Update registry
p=os.path.expanduser('~/.openclaw/workspace/agents/registry.json')
os.makedirs(os.path.dirname(p), exist_ok=True)
d={}
if os.path.exists(p):
  try:d=json.load(open(p))
  except Exception:d={}
d[agent]={
  "port":port,
  "role":role.strip(),
  "personality":personality.strip(),
  "home":home,
  "guild_id":"__DISCORD_GUILD_ID__",
  "channel_id":"__DISCORD_CHANNEL_ID__"
}
json.dump(d, open(p,'w'), indent=2)

# 2) Write agent SOUL.md identity section
agent_ws=os.path.expanduser(f'~/.openclaw/workspace/{agent}')
os.makedirs(agent_ws, exist_ok=True)
soul_path=os.path.join(agent_ws, 'SOUL.md')
base="" 
if os.path.exists(soul_path):
  base=open(soul_path, 'r', encoding='utf-8').read().rstrip()+"\n\n"
identity_block=(
  "## Identity\n\n"
  f"- Name: {agent}\n"
  f"- Role: {role.strip()}\n"
  f"- Personality: {(personality or role_raw).strip()}\n"
)
open(soul_path, 'w', encoding='utf-8').write(base + identity_block)

# 3) Add/update shared TEAM.md roster
shared_dir=os.path.expanduser('~/.openclaw/workspace/shared')
os.makedirs(shared_dir, exist_ok=True)
team_path=os.path.join(shared_dir, 'TEAM.md')
entry=(
  f"- **{agent}**\n"
  f"  - role: {role.strip()}\n"
  f"  - personality: {(personality or role_raw).strip()}\n"
  f"  - port: {port}\n"
)
start=f"<!-- AGENT:{agent}:START -->"
end=f"<!-- AGENT:{agent}:END -->"
block=f"{start}\n{entry}{end}\n"
if os.path.exists(team_path):
  t=open(team_path, 'r', encoding='utf-8').read()
else:
  t="# TEAM.md\n\n## Agents\n\n"
if start in t and end in t:
  import re
  t=re.sub(re.escape(start)+r".*?"+re.escape(end)+r"\\n?", block, t, flags=re.S)
else:
  if "## Agents" not in t:
    t=t.rstrip()+"\n\n## Agents\n\n"
  t=t.rstrip()+"\n\n"+block
open(team_path, 'w', encoding='utf-8').write(t)

print(json.dumps({"agent_id":agent,"port":port,"home":home,"guild_id":"__DISCORD_GUILD_ID__","channel_id":"__DISCORD_CHANNEL_ID__","guild_configured":True,"status":"started"}))
PY
